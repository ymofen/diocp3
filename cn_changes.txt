DIOCP 3.5.01
1.修复DHashTable中计算数组位置时可能出现负数，而导致访问违规错误（2014-10-20 14:18:43）

2.在AcceptEx出现异常后，销毁Socket句柄，以免下次重用时出现相同的错误。

3.响应完成后TIocpRecvRequest.HandleResponse，
  先判断是否需要再次投递RecvRequest,然后再减少Context的引用计算器。避免该Context进行返回到连接池后，又进行借出。导致在后面再进行操作时对应的Context不对应

4.添加TIocpCoderClient组件，客户端应用，可以对单个客户端连接注册解码器和编码器,可以连接多个服务器，统一由同一个iocp引擎进行管理。
  DEMO位与:samples\socket-Coder\diocpPusher\Client - IocpCoderClient
  2014-10-23 12:53:07

5.编码器/解码器模式，在连接上下文关闭时，清理已经接收数据，以免上下文对象再次使用时，出现解码错误。感谢(綦y留?  278010908)反馈bug
  2014-10-31 22:09:43

6.优化了PostSendRequest流程

DIOCP 3.5.02 
  2014-11-02 00:25:41

1.TIOCPBaseSocket(客户端IOCP连接上下文)，在关闭后，再一次进行关闭时包Assert异常)
  :修复了重复调用客户端关闭的问题
  2014-11-03 23:06:58

2.添加DRawSocket.pas，可以用于跨平台
  2014年11月6日 22:39:14

3.添加DTcpClient.pas, 可以用于跨平台
  2014年11月6日 22:39:39

4.TDTcpClientCoderImpl实现了ICodeSocket接口，可以用与跨平台
  2014年11月6日 22:45:54

5.添加客户端添加Andriod使用的DEMO[samples\socket-Coder\DataModuleDEMO-Andriod]
  2014-11-09 17:09:30

6.在响应WSARecv处理中(TIocpRecvRequest.HandleResponse)最后记录日志时,
  在继续投递了WSARecv之后访问了对象的全局字符串变量可能会造成记录状态时出现访问冲突。
  在投递之前用过程的局部变量进行记录, 然后再投递WSARecv。记录状态日志时使用过程的局部变量
  2014-11-09 22:41:57

DIOCP 3.5.03
  2014-11-11 22:31:23

1.DRawSocket 添加GetIpByName跨平台的解析域名到IP地址的函数。
  2014-11-11 12:32:48
  
2.优化发送数据发送TIocpSendRequest发送流程。
  1>去掉FCanGiveBack属性。
  2>增加引用计数，在WSASend +1, 在ResponseDone时 -1 如果=0时 换回对象池。
  3>添加OnResponseCompletedDone虚函数，在TIocpSendRequest还回对象池之前进行调用。
  *TIocpSendRequest可以推送大于WSASendBlockSize的数据，推送时会一块块进行推送，在响应完成时会进行下一块数据的推送<下一块的投递可能得到第二个线程的立即执行>
  2014-11-11 22:50:48
  
3.进一步精简发送流程。
  1>去掉底层的TIocpSendRequest分包方案，上一层一次性投递多少就发送多少数据
  2>PostWSASendBuffer添加参数SendBufferReleaseType，可以决定投递完成的Buffer处理方式。
  2014-11-11 23:57:35

4.添加文件服务器DEMO。客户端基于MyBean插件。可以直接使用。
  2014-11-12 13:07:29

5.同步iocpBaseSocket.TIocpSendRequest的发送流程和IocpTcpServer.TIocpSendRequest一致
  2014-11-12 23:05:17